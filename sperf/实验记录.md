# å‰è¨€

è¿™å‡ èŠ‚è¯¾åŠ æ·±äº†å¯¹äºæ“ä½œç³»ç»Ÿçš„æŸäº›æ–¹é¢çš„äº†è§£ï¼Œä¸‹é¢ç®€å•ä»‹ç»ä¸€ä¸‹è¿›ç¨‹æŠ½è±¡çš„ç›¸å…³é—®é¢˜ï¼Œå¹¶å®ç°è¯¾ç¨‹ä¸­çš„M3å®éªŒ

# è¿›ç¨‹æŠ½è±¡

## forkç³»ç»Ÿè°ƒç”¨

ä¹‹å‰æˆ‘ä»¬ä¸€ç›´å°†è¿›ç¨‹å½“ä½œä¸€ä¸ª**çŠ¶æ€æœº**ã€‚é‚£ä¹ˆå¦‚æœæˆ‘ä»¬æƒ³è¦åˆ›å»ºä¸€ä¸ªæ–°çš„è¿›ç¨‹ï¼Œä¹Ÿå°±æ˜¯åˆ›å»ºä¸€ä¸ªæ–°çš„**çŠ¶æ€æœº**å³å¯ã€‚

åœ¨Linuxä¸­ï¼Œæ“ä½œç³»ç»Ÿæä¾›äº†**fork**ç³»ç»Ÿè°ƒç”¨ï¼Œå…¶ä¼šå°†å½“å‰çš„è¿›ç¨‹ï¼Œå³å½“å‰çš„çŠ¶æ€æœº(åŒ…æ‹¬å†…å­˜å’Œå¯„å­˜å™¨)ï¼Œå®Œæ•´çš„å¤åˆ¶ä¸€ä»½ï¼Œä»è€Œåˆ›å»ºäº†æ–°çš„è¿›ç¨‹ã€‚

å…·ä½“çš„ï¼Œå¯ä»¥æ ¹æ®**man 2 fork**ï¼ŒæŸ¥çœ‹æ¥å£ä¿¡æ¯ï¼Œå¦‚ä¸‹æ‰€ç¤º

```c
#include <unistd.h>

/*
On success, the PID of the child process is returned in the parent,  and  0  is
returned  in  the  child.   On  failure, -1 is returned in the parent, no child
process is created, and errno is set to indicate the error.
*/

pid_t fork(void);
```

### fork bomb

è‡ªç„¶çš„ï¼Œæˆ‘ä»¬å¯ä»¥æƒ³åˆ°ï¼Œæ“ä½œç³»ç»Ÿç®¡ç†è¿›ç¨‹æ˜¯éœ€è¦èµ„æºçš„ã€‚é‚£ä¹ˆç†è®ºä¸Šï¼Œæˆ‘ä»¬åªè¦ä¸åœåœ°åˆ›å»ºè¿›ç¨‹ï¼Œç³»ç»Ÿæœ€åä¼šå› ä¸ºèµ„æºè€—å°½è€Œå´©æºƒã€‚
åŸºäºè¿™ä¸ªåŸç†ï¼Œæœ‰ä¸€ä¸ªç»å…¸çš„å‘½ä»¤â€”â€”**fork bomb**ï¼Œå…¶ä¼šä»¥æŒ‡æ•°çº§åˆ«çš„å¢é•¿é€Ÿåº¦åˆ›å»ºè¿›ç¨‹ï¼Œä»è€Œä½¿è¿›ç¨‹å´©æºƒã€‚

**fork bomb**çš„ç»å…¸å‘½ä»¤æ ¼å¼å¦‚ä¸‹æ‰€ç¤º

```bash
$ :(){:|:&};:
```

å¯ä»¥çœ‹åˆ°ï¼Œè¿™ä¸ªå‘½ä»¤æœ‰ç‚¹**tricky**ï¼Œæˆ‘ä»¬ç®€å•çš„åˆ†æä¸€ä¸‹è¯¥å‘½ä»¤ã€‚

é¦–å…ˆï¼Œåœ¨bashä¸­ï¼Œ`:`å¯ä»¥ä½œä¸ºæ ‡è¯†ç¬¦ï¼Œä¹Ÿå°±æ˜¯å…¶å¯ä»¥ä½œä¸ºä¸€ä¸ªç¬¦å·ï¼Œé‚£æˆ‘ä»¬å°†å…¶æ›´æ¢ä¸ºä¸€ä¸ªæ›´ç¾è§‚çš„æ ‡è¯†ç¬¦**fork**ï¼Œè½¬æ¢åçš„å‘½ä»¤å¦‚ä¸‹

```
fork(){fork|fork&};fork
```

æ­¤æ—¶å¯ä»¥å¤§è‡´çœ‹å‡ºæ¥ï¼Œè¿™å°±æ˜¯å®šä¹‰äº†ä¸€ä¸ªå‡½æ•°ï¼Œç„¶ååœ¨è¿›è¡Œè°ƒç”¨å³å¯ã€‚**bash**ä¸­çš„åˆ†å·è¡¨ç¤ºä¸€ä¸ªæ¢è¡Œï¼Œè¿™é‡Œæˆ‘ä»¬åœ¨ç¾åŒ–ä¸€ä¸‹å‘½ä»¤ï¼Œæ·»åŠ é€‚å½“çš„ç©ºç™½å’Œæ¢è¡Œï¼Œå¦‚ä¸‹æ‰€ç¤º

```
fork() {
	fork | fork &
}
fork
```

å¯ä»¥çœ‹åˆ°ï¼Œå…¶ä»¥äºŒçš„å¹‚çš„å¢é•¿é€Ÿåº¦åˆ›å»ºè¿›ç¨‹ï¼Œä»è€Œå¾ˆå¿«å¯¼è‡´ç³»ç»Ÿå´©æºƒ

### forkä¸­çš„ç¼“å†²é—®é¢˜

å®é™…ä¸Šï¼Œè™½ç„¶å‰é¢ä»‹ç»**fork**çš„æ—¶å€™ï¼Œåªæ˜¯ç®€å•çš„ä»¥**å°†å½“å‰çš„çŠ¶æ€æœº(åŒ…æ‹¬å†…å­˜å’Œå¯„å­˜å™¨)å¤åˆ¶ä¸€ä»½**ä»‹ç»ï¼Œä½†æ˜¯ä¸­é—´æœ‰éå¸¸ç¹æ‚çš„ç»†èŠ‚ï¼Œä¾‹å¦‚ç¼“å†²é—®é¢˜ã€‚

é¦–å…ˆç®€å•çš„åˆ†æä¸€ä»½ä»£ç ï¼Œå¦‚ä¸‹æ‰€ç¤º

```c
#include <stdio.h>
#include <unistd.h>

int main() {
	for(int i = 0; i < 2; ++i) {
		fork();
		printf("hawk\n");
	}
}
```

è¿™ä»½ä»£ç åˆ†æèµ·æ¥å¹¶ä¸æ˜¯å¾ˆå¤æ‚ï¼Œæˆ‘ä»¬åªè¦æ ¹æ®çŠ¶æ€æœºç†è®ºï¼Œç”»ä¸€ä¸ªçŠ¶æ€å›¾å³å¯ï¼Œå¦‚ä¸‹æ‰€ç¤º

![](../images/forkçŠ¶æ€å›¾1.PNG)

å¯ä»¥çœ‹åˆ°ï¼Œä»ç†è®ºä¸Šè¿›è¡Œåˆ†æï¼Œæœ€åè¯¥ç¨‹åºåº”è¯¥ä¼šæ‰§è¡Œ6æ¬¡**printf**ï¼Œé‚£ä¹ˆç¨‹åºæ€»å…±ä¼šåœ¨ç»ˆç«¯ä¸Šè¾“å‡º6è¡Œ**hawk**ã€‚ä½†æ˜¯æˆ‘ä»¬è¿›è¡Œå¦‚ä¸‹æµ‹è¯•ï¼Œä¼šå¾—åˆ°åŒªå¤·æ‰€æ€çš„ç»“æœ

```bash
$ ./fork-printf 
hawk
hawk
hawk
hawk
hawk
hawk
$ ./fork-printf | wc -l
8
```

å¦‚æœç›´æ¥è¾“å‡ºï¼Œç¨‹åºç¡®å®æ˜¯é¢„æœŸçš„ç»“æœ;ä½†å¦‚æœæˆ‘ä»¬å°†è¾“å‡ºé‡å®šå‘ï¼Œåˆ™å…¶åè€Œä¼šè¾“å‡º8è¡Œ**hawk**ï¼Œä¸é¢„æœŸä¸åŒ
å®é™…ä¸Šï¼Œè¿™å°±æ˜¯ç¼“å†²å¯¼è‡´çš„é—®é¢˜â€”â€”æ­£å¸¸æƒ…å†µä¸‹ï¼Œglibcæ˜¯è¡Œç¼“å†²:å³é‡åˆ°â€™\nâ€™ï¼Œå°±å°†ç¼“å†²åŒºè¾“å‡ºåˆ°æ ‡å‡†è¾“å‡ºä¸Š;è€Œå½“æˆ‘ä»¬ä½¿ç”¨ç®¡é“åï¼Œç®¡é“è¿˜ä¼šä½¿ç”¨è‡ªå·±çš„ç¼“å†²åŒºï¼Œå¯ä»¥é€šè¿‡**ulimit -a | grep â€œpipe sizeâ€**æŸ¥çœ‹ç¼“å†²åŒºå¤§å°ã€‚
ç»“åˆè¿™ä¸ªé—®é¢˜ï¼Œå®é™…ä¸Šå¯ä»¥å¾ˆå¥½è¿›è¡Œåˆ†æâ€”â€”å³åœ¨å¤åˆ¶çŠ¶æ€æœºçš„çŠ¶æ€æ—¶ï¼Œå…¶ä¼šå°†å†…å­˜å’Œå¯„å­˜å™¨ç­‰ä¸€å¹¶è¿›è¡Œå¤åˆ¶ï¼Œè€Œç¼“å†²åŒºä¹Ÿæ˜¯å­˜åœ¨äºå†…å­˜ä¸­çš„ï¼Œè‡ªç„¶ä¹Ÿä¼šä¸€å¹¶å¤åˆ¶è¿‡æ¥ï¼Œä»è€Œå¯¼è‡´è¿™ä¸ªé—®é¢˜ã€‚å…·ä½“çš„æˆ‘ä»¬ä»ç„¶å¯ä»¥ç»“åˆçŠ¶æ€å›¾è¿›è¡Œåˆ†æã€‚

![](../images/forkçŠ¶æ€å›¾2.PNG)

å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœè€ƒè™‘åˆ°ç¼“å†²çš„è¯ï¼Œå…¶ç¡®å®ä¼šè¾“å‡º8è¡Œ**hawk**ã€‚

ä¸ºäº†ç¡®è®¤æˆ‘ä»¬çš„çŒœæƒ³ï¼Œæ‰§è¡Œå¦‚ä¸‹å‘½ä»¤è¿›è¡ŒéªŒè¯

```bash
$ (stdbuf -o0 ./fork-printf) | wc -l
6
```

## execveç³»ç»Ÿè°ƒç”¨

å½“æˆ‘ä»¬æƒ³è¦åˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦å…¶æ‰§è¡Œå…¶ä»–çš„å‘½ä»¤ã€‚æ­¤æ—¶ï¼Œä»…ä»…ç”¨**fork**ç³»ç»Ÿè°ƒç”¨æ˜¯ä¸å¤Ÿçš„ï¼Œè¿˜éœ€è¦ç”¨**execve**ç³»ç»Ÿè°ƒç”¨ï¼Œå°†å½“å‰çš„çŠ¶æ€æœºçŠ¶æ€é‡ç½®æˆå¦ä¸€ä¸ªç¨‹åºçš„åˆå§‹çŠ¶æ€ã€‚

ç±»ä¼¼äº**fork**ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡**man 2 execve**æŸ¥çœ‹è¯¥ç³»ç»Ÿè°ƒç”¨çš„æ¥å£ä¿¡æ¯ï¼Œå¦‚ä¸‹æ‰€ç¤º

```c
#include <unistd.h>


/*       
       execve() executes the program referred to by pathname.  This causes the program
       that is currently being run by the calling process to be replaced  with  a  new
       program,  with  newly  initialized stack, heap, and (initialized and uninitialâ€
       ized) data segments.
*/
int execve(const char *pathname, char *const argv[], char *const envp[]);


/*
       pathname must be either a binary executable, or a script starting with  a  line
       of the form:

           #!interpreter [optional-arg]

       For details of the latter case, see "Interpreter scripts" below.

       

       argv  is  an array of pointers to strings passed to the new program as its comâ€
       mand-line arguments.  By convention, the first of these strings (i.e., argv[0])
       should  contain the filename associated with the file being executed.  The argv
       array must be terminated by  a  NULL  pointer.   (Thus,  in  the  new  program,
       argv[argc] will be NULL.)



       envp  is an array of pointers to strings, conventionally of the form key=value,
       which are passed as the environment of the new program.  The envp array must be
       terminated by a NULL pointer.
*/
```

## _exitç³»ç»Ÿè°ƒç”¨

ç†è®ºä¸Šï¼Œå½“æˆ‘ä»¬æœ‰äº†**fork**ã€**execve**ç³»ç»Ÿè°ƒç”¨åï¼Œæˆ‘ä»¬å°±å¯ä»¥è‡ªç”±çš„æ‰§è¡Œä»»æ„ç¨‹åºäº†ã€‚è™½ç„¶å¦‚æ­¤ï¼Œä½†æˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œç”¨æ¥ä¸­æ­¢å½“å‰çš„çŠ¶æ€æœº(çŠ¶æ€æœºè‡ªèº«åªèƒ½ä¸åœçš„è·³è½¬åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€)ã€‚

Linuxä¸ºæ­¤æä¾›äº†**_exit()**ç³»ç»Ÿè°ƒç”¨ï¼Œç”¨æ¥ç«‹å³é”€æ¯å½“å‰è¿›ç¨‹ï¼Œæˆ–è€…è¯´æ˜¯çŠ¶æ€æœºã€‚åŒæ ·çš„ï¼Œå¯ä»¥é€šè¿‡**man 2 _exit**æŸ¥çœ‹è¯¥ç³»ç»Ÿè°ƒç”¨çš„æ¥å£ä¿¡æ¯ï¼Œå¦‚ä¸‹æ‰€ç¤º

```c
#include <unistd.h>

/*
	   _exit()  terminates  the calling process "immediately".  Any open file descripâ€
       tors belonging to the process are closed.  Any children of the process are  inâ€
       herited  by  init(1)  (or by the nearest "subreaper" process as defined through
       the use of the prctl(2) PR_SET_CHILD_SUBREAPER operation).  The process's  parâ€
       ent is sent a SIGCHLD signal.
*/
noreturn void _exit(int status);


/*

C library/kernel differences
       In  glibc  up  to  version 2.3, the _exit() wrapper function invoked the kernel
       system call of the same name.  Since glibc 2.3, the  wrapper  function  invokes
       exit_group(2), in order to terminate all of the threads in a process.

       The  raw  _exit()  system  call terminates only the calling thread, and actions
       such as reparenting child processes or sending SIGCHLD to  the  parent  process
       are performed only if this is the last thread in the thread group.
*/
```

# M3ç³»ç»Ÿè°ƒç”¨Profiler(sperf)

## å®éªŒèƒŒæ™¯

**ç¨‹åºå°±æ˜¯ä¸€ä¸ªçŠ¶æ€æœº**ï¼Œè€Œæ“ä½œç³»ç»Ÿä¸Šçš„ç¨‹åºåˆé€šè¿‡**ç³»ç»Ÿè°ƒç”¨**å’Œæ“ä½œç³»ç»Ÿäº¤äº’ã€‚

è™½ç„¶å¦‚æ­¤ï¼Œå¦‚æœä¸çœ‹çœ‹å®é™…ç¨‹åºæ‰§è¡Œçš„ç³»ç»Ÿè°ƒç”¨ï¼Œå¯¹æ“ä½œç³»ç»Ÿçš„ç†è§£ä»ç„¶æ˜¯å¾ˆç‰‡é¢çš„ã€‚

æ‰€å¹¸æ“ä½œç³»ç»Ÿæä¾›äº†è¶³å¤Ÿçš„å·¥å…·æ¥æŸ¥çœ‹â€”â€”å³è¿½è¸ªå·¥å…·**trace**ã€‚**trace**å·¥å…·æ˜¯ç³»ç»Ÿç¼–ç¨‹æ—¶éå¸¸å¸¸ç”¨çš„é—®é¢˜è¯Šæ–­å·¥å…·ã€‚æ ¹æ®è°ƒè¯•ç†è®ºï¼Œ**trace**åœ¨ä¸€å®šç¨‹åº¦ä¸Šåæ˜ äº†ç¨‹åºæ‰§è¡Œçš„æµç¨‹ï¼Œå› æ­¤å¯ä»¥å¸®åŠ©ä½ ç¼©å°bugæ‰€åœ¨çš„èŒƒå›´;æ­¤å¤–ï¼Œ**trace**ä¸­é¢å¤–çš„ä¿¡æ¯è¿˜èƒ½å¸®åŠ©è¯Šæ–­æ€§èƒ½ç­‰é—®é¢˜ã€‚

å¦‚æœæˆ‘ä»¬å¯¹**trace**è¿›è¡Œä¸€å®šçš„åˆ†æï¼Œå°±å¯ä»¥å°†å…¶ç»“æœæ›´ä¼˜ç¾çš„è¿›è¡Œå±•ç¤ºã€‚åœ¨æœ¬æ¬¡å®éªŒä¸­ï¼Œå¯ä»¥å€ŸåŠ©**strace**å®ç°ä¸€ä¸ªç¨‹åºçš„**æ€§èƒ½è¯Šæ–­**å·¥å…·ï¼Œå…¶å¯ä»¥é€šè¿‡åˆ†æ**trace**çš„è¾“å‡ºï¼Œä»è€Œåˆ†æç³»ç»Ÿè°ƒç”¨çš„æ€§èƒ½ä¿¡æ¯

## å®éªŒæè¿°

> å®ç°å‘½ä»¤è¡Œå·¥å…·*sperf*:
>
> sperf COMMAND [ARG] ...
>
> å…¶ä¼šåœ¨ç³»ç»Ÿä¸­æ‰§è¡Œ**COMMAND**å‘½ä»¤(å¦‚æœ**COMMAND**æ˜¯ä»¥/å¼€å¤´çš„ç»å¯¹è·¯å¾„ï¼Œåˆ™ç›´æ¥æ‰§è¡Œ;å¦åˆ™åœ¨**PATH**ç¯å¢ƒå˜é‡ä¸­æœç´¢åˆ°ç¬¬ä¸€ä¸ªå­˜åœ¨ä¸”å¯æ‰§è¡Œçš„æ–‡ä»¶)ï¼Œå¹¶ä¸º**COMMAND**ä¼ å…¥ARGå‚æ•°ï¼Œç„¶åç»Ÿè®¡å‘½ä»¤æ‰§è¡Œçš„ç³»ç»Ÿè°ƒç”¨æ‰€å ç”¨æ—¶é—´ï¼Œæœ€ååœ¨å±å¹•ä¸Šæ˜¾ç¤ºå‡ºè€—æ—¶æœ€å¤šçš„è‹¥å¹²ä¸ªç³»ç»Ÿè°ƒç”¨çš„æ—¶é—´
> ä¸€äº›å‡è®¾å’Œçº¦å®š:
>
> - è¾“å‡ºçš„å½¢å¼ä¸é™ã€‚å¯¹äºè¾ƒçŸ­æ—¶é—´è¿è¡Œçš„ç¨‹åºï¼Œå¯ä»¥ä¸€æ¬¡æ€§æ‰“å°å‡ºè€—æ—¶æœ€å¤šçš„å‡ ä¸ªç³»ç»Ÿè°ƒç”¨;å¯¹äºè€—æ—¶è¾ƒé•¿çš„ç¨‹åºï¼Œéœ€è¦å®šæœŸ(å¦‚æ¯ç§’)æ‰“å°å‡ºç³»ç»Ÿè°ƒç”¨çš„è€—æ—¶ä¿¡æ¯;
> - å‡è®¾**COMMAND**æ˜¯å•è¿›ç¨‹ã€å•çº¿ç¨‹çš„ï¼Œæ— éœ€å¤„ç†å¤šè¿›ç¨‹å’Œå¤šçº¿ç¨‹çš„æƒ…å†µ
> - å¿…é¡»ä½¿ç”¨**execve**ç³»ç»Ÿè°ƒç”¨ï¼Œè€Œé**glibc**å¯¹äº**execve**çš„åŒ…è£…(å¦‚**execl**ã€**execlp**ã€**execle**ã€**execv**ã€**execvp**æˆ–**execvpe**)

## å®éªŒæŒ‡å—

åœ¨è¯¥å®éªŒä¸­ï¼Œå…¶å¤§ä½“ä¸Šå¯ä»¥åˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†

1. åˆ›å»ºå­è¿›ç¨‹ï¼Œåœ¨å­è¿›ç¨‹ä¸­å¯åŠ¨**strace**(é€šè¿‡**fork**/**execve**ç³»ç»Ÿè°ƒç”¨)
2. åœ¨çˆ¶è¿›ç¨‹ä¸­æ•è·**strace**çš„è¾“å‡º(é€šè¿‡**pipe**ç³»ç»Ÿè°ƒç”¨)
3. è§£ææ•è·çš„**strace**è¾“å‡ºï¼Œå¹¶æŠŠç³»ç»Ÿè°ƒç”¨çš„æ—¶é—´ä¿¡æ¯ç»Ÿè®¡æ˜¾ç¤º

### æ˜¾ç¤ºç³»ç»Ÿè°ƒç”¨åºåˆ—

åœ¨è¯¥å®éªŒä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦é€šè¿‡**strace**ï¼Œå°±å¯ä»¥æ–¹ä¾¿çš„æŸ¥çœ‹æ•´ä¸ªç¨‹åºä»**å¤´**å¼€å§‹çš„æŒ‰é¡ºåºçš„ä¸€ç³»åˆ—çš„ç³»ç»Ÿè°ƒç”¨
å› æ­¤ï¼Œæœ¬è´¨ä¸Šï¼Œè¯¥å®éªŒå°±æ˜¯è§£æ**strace**çš„è¾“å‡º

### æ˜¾ç¤ºç³»ç»Ÿè°ƒç”¨çš„æ—¶é—´(strace)

æ ¹æ®å®éªŒè¦æ±‚ï¼Œæˆ‘ä»¬ä¸ä»…éœ€è¦åˆ†æç¨‹åºçš„ç³»ç»Ÿè°ƒç”¨çš„åºåˆ—ï¼Œè¿˜éœ€è¦ç»Ÿè®¡æ¯ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨çš„æ—¶é—´å æ¯”ã€‚è€Œè¿™ä¹Ÿå°±æ˜¯è¦æ±‚**strace**è¾“å‡ºä¸­ä¹Ÿåº”è¯¥åŒ…å«æ¯ä¸€æ¬¡ç³»ç»Ÿè°ƒç”¨æ‰€æ¶ˆè€—çš„æ—¶é—´ã€‚

é€šè¿‡`man strace`å¯ä»¥å¾ˆè½»æ˜“çš„æŸ¥åˆ°å¦‚ä¸‹çš„ä¿¡æ¯

```
--syscall-times[=precision]
                   Show the time spent in system calls.  This records the time difference between the
                   beginning  and  the  end of each system call.  precision can be one of s (for secâ€
                   onds), ms (milliseconds), us (microseconds), or ns (nanoseconds), and allows  setâ€
                   ting the precision of time value being printed.  Default is us (microseconds).
```

å› æ­¤ï¼Œæˆ‘ä»¬åœ¨è°ƒç”¨**strace**æ—¶ï¼Œæ·»åŠ ç›¸å…³çš„å‚æ•°å³å¯

~~å®é™…ä¸Šåœ¨manä¸­å¯ä»¥ç›´æ¥æ‰¾åˆ°è¾“å‡ºç³»ç»Ÿè°ƒç”¨åŠå…¶æ—¶é—´ç™¾åˆ†æ¯”çš„å‚æ•°ï¼Œå³`strace -cU time-percent`, ä½†æ˜¯æœ‰ç‚¹ä½œå¼Š~~

### spert:è®¾è®¡

ç±»ä¼¼äºå‰é¢çš„M1å®éªŒâ€”â€”å…¶å°†**pstree**åˆ†è§£æˆå¤šä¸ªæ›´ç®€å•çš„å­éƒ¨åˆ†è¿›è¡Œè§£å†³;è¿™é‡Œä¹Ÿå°†**sperf**åˆ†è§£æˆå‡ ä¸ªæ›´ä¸ºç®€å•çš„éƒ¨ä»¶è¿›è¡Œè§£å†³ã€‚

1. è§£æå‡º**COMMAND**å’Œ**ARG**â€”â€”å°±æ˜¯**main**çš„ç›¸å…³å‚æ•°

2. ä½¿ç”¨ **fork** åˆ›å»ºä¸€ä¸ªæ–°çš„è¿›ç¨‹:

    1. å­è¿›ç¨‹ä½¿ç”¨ `execve`è°ƒç”¨ `strace COMMAND ARG ...`ï¼Œå¯åŠ¨ä¸€ä»½ **strace**

        - åœ¨`execve`æˆåŠŸè¿”å›ä»¥åï¼Œå­è¿›ç¨‹å·²ç»ä¸å†å—æ§åˆ¶äº†ã€‚`strace`ä¼šä¸æ–­è¾“å‡ºç³»ç»Ÿè°ƒç”¨çš„traceï¼Œç›´åˆ°ç¨‹åºç»“æŸã€‚å½“ç„¶ï¼ŒCOMMANDå‘½ä»¤ä¸ç»“æŸï¼Œ`strace`ä¹Ÿä¸ä¼šç»“æŸ
    2. çˆ¶è¿›ç¨‹æƒ³åŠæ³•ä¸æ–­è¯»å–`strace`çš„è¾“å‡ºï¼Œç›´åˆ°**strace**ç¨‹åºç»“æŸ

        - èƒ½è¯»å–åˆ°è¾“å‡ºï¼Œå°±å¯ä»¥è§£æå‡ºæ¯ä¸ªç³»ç»Ÿè°ƒç”¨çš„æ—¶é—´ï¼Œä»è€ŒæŠŠç»Ÿè®¡ä¿¡æ¯æ‰“å°åˆ°å±å¹•ä¸Š

### ä½¿ç”¨execveåˆ›å»ºå­è¿›ç¨‹

å®éªŒä¸­å·²ç»æ˜ç¡®è¦æ±‚äº†ï¼Œå¿…é¡»ä½¿ç”¨`execve`æ‰§è¡Œç¨‹åºï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦é€šè¿‡`man 2 execve`è¯¦ç»†äº†è§£ä¸€ä¸‹è¯¥å‡½æ•°çš„ä¿¡æ¯ï¼Œå…¶å†…å®¹å¦‚ä¸‹æ‰€ç¤º

```c
#include <unistd.h>

int execve(const char *pathname, char *const argv[],
           char *const envp[]);
```

è¿™é‡Œå¯èƒ½ä¼šæœ‰å‡ ä¸ªé—®é¢˜:

1. **pathname**æ˜¯ç›¸å¯¹äºè¿›ç¨‹çš„å½“å‰ç›®å½•(**current working directory**)è€Œè¨€çš„ï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªç»å¯¹è·¯å¾„ã€‚å¦‚æœé”™è¯¯çš„ä¼ å…¥å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„ï¼Œåˆ™**execve**æ— æ³•æ­£ç¡®æ‰§è¡Œ
2. ä¼ å…¥æ­£ç¡®çš„**argv**ã€‚åœ¨è¯¾ä»¶ä¸­å®é™…ä¸Šæœ‰ä¸€ä¸ªéå¸¸ä¼˜ç¾çš„å†™æ³•
3. ä¼ å…¥æ­£ç¡®çš„**envp**ã€‚éƒ¨åˆ†ç¨‹åºçš„è¿è¡Œä¾èµ–äºæ­£ç¡®çš„ç¯å¢ƒå˜é‡ï¼Œå¦åˆ™å¯èƒ½å¯¼è‡´ç¨‹åºçš„å¼‚å¸¸

### è¿æ¥çˆ¶å­è¿›ç¨‹çš„è¾“å…¥

ä½¿ç”¨`pipe`ç³»ç»Ÿè°ƒç”¨ï¼Œå¯ä»¥åˆ›å»ºä¸€ä¸ªç®¡é“ï¼Œé€šè¿‡`man 2 pipe`æŸ¥çœ‹è¯¥ç³»ç»Ÿè°ƒç”¨çš„è¯¦ç»†ä¿¡æ¯ï¼Œå¦‚ä¸‹æ‰€ç¤º

```c
#include <unistd.h>

int pipe(int pipefd[2]);

/*
       pipe()  creates  a  pipe, a unidirectional data channel that can be used for interprocess communication.  The array pipefd is used to return two file descriptors referring to the ends of the
       pipe.  pipefd[0] refers to the read end of the pipe.  pipefd[1] refers to the write end of the pipe.  Data written to the write end of the pipe is buffered by the kernel  until  it  is  read
       from the read end of the pipe.  For further details, see pipe(7).


       On success, zero is returned.  On error, -1 is returned, errno is set appropriately, and pipefd is left unchanged.
       On Linux (and other systems), pipe() does not modify pipefd on failure.  A requirement standardizing this behavior was added in POSIX.1-2016.  The Linux-specific pipe2() system call likewise
       does not modify pipefd on failure.
*/
```

`man`æ‰‹å†Œä¸­ä¹Ÿç»™å‡ºäº†ç›¸å…³çš„ä½¿ç”¨æ ·ä¾‹ï¼Œå¦‚ä¸‹æ‰€ç¤º

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int
main(int argc, char *argv[])
{
    int pipefd[2];
    pid_t cpid;
    char buf;

    if (argc != 2) {
        fprintf(stderr, "Usage: %s <string>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    cpid = fork();
    if (cpid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (cpid == 0) {    /* Child reads from pipe */
        close(pipefd[1]);          /* Close unused write end */

        while (read(pipefd[0], &buf, 1) > 0)
            write(STDOUT_FILENO, &buf, 1);

        write(STDOUT_FILENO, "\n", 1);
        close(pipefd[0]);
        _exit(EXIT_SUCCESS);

    } else {            /* Parent writes argv[1] to pipe */
        close(pipefd[0]);          /* Close unused read end */
        write(pipefd[1], argv[1], strlen(argv[1]));
        close(pipefd[1]);          /* Reader will see EOF */
        wait(NULL);                /* Wait for child */
        exit(EXIT_SUCCESS);
    }
}
```

å¯ä»¥çœ‹åˆ°ï¼Œä½¿ç”¨**pipefd**ï¼Œå’Œä½¿ç”¨æ™®é€šçš„æ–‡ä»¶æè¿°ç¬¦æ²¡æœ‰ä»€ä¹ˆåŒºåˆ«â€”â€”åªä¸è¿‡**pipefd**æŒ‡å®šäº†`pipefd[0]`åªèƒ½è¯»;`pipefd[1]`åªèƒ½å†™

å®éªŒæŒ‡å—ä¸­è¿˜é¢å¤–æŒ‡æ˜äº†ï¼Œå¯èƒ½éœ€è¦**dup2**ç³»ç»Ÿè°ƒç”¨è¿›è¡Œæ–‡ä»¶æè¿°ç¬¦çš„è…¾æŒªï¼Œè¿™é‡ŒåŒæ ·é€šè¿‡`man 2 dup2`ï¼ŒæŸ¥çœ‹è¯¥ç³»ç»Ÿè°ƒç”¨çš„ç›¸å…³ä¿¡æ¯

```c
#include <unistd.h>

int dup(int oldfd);
/*

       The dup() system call creates a copy of the file descriptor oldfd, using the lowest-numbered unused file descriptor for the new descriptor.

       After  a successful return, the old and new file descriptors may be used interchangeably.  They refer to the same open file description (see open(2)) and thus share file offset and file staâ€
       tus flags; for example, if the file offset is modified by using lseek(2) on one of the file descriptors, the offset is also changed for the other.

       The two file descriptors do not share file descriptor flags (the close-on-exec flag).  The close-on-exec flag (FD_CLOEXEC; see fcntl(2)) for the duplicate descriptor is off.
*/


int dup2(int oldfd, int newfd);
/*
       The dup2() system call performs the same task as dup(), but instead of using the lowest-numbered unused file descriptor, it uses the file descriptor number specified in newfd.  If  the  file
       descriptor newfd was previously open, it is silently closed before being reused.

       The  steps  of closing and reusing the file descriptor newfd are performed atomically.  This is important, because trying to implement equivalent functionality using close(2) and dup() would
       be subject to race conditions, whereby newfd might be reused between the two steps.  Such reuse could happen because the main program is interrupted by a signal handler that allocates a file
       descriptor, or because a parallel thread allocates a file descriptor.

       Note the following points:

       *  If oldfd is not a valid file descriptor, then the call fails, and newfd is not closed.

       *  If oldfd is a valid file descriptor, and newfd has the same value as oldfd, then dup2() does nothing, and returns newfd.
*/
```

å®é™…ä¸Šï¼Œä¹Ÿå°±æ˜¯ç”¨æ¥é‡å®šå‘æ–‡ä»¶æè¿°ç¬¦çš„ç³»ç»Ÿè°ƒç”¨

### è§£æstraceçš„è¾“å‡º

å®é™…ä¸Šï¼Œ**strace**çš„è¾“å‡ºç±»ä¼¼äºä¸€è¡Œcå‡½æ•°çš„è°ƒç”¨ï¼Œå› æ­¤è§£æ**strace**çš„è¾“å‡ºï¼Œä¹Ÿå°±ç›¸å½“äºä¸€ä¸ª**å­—ç¬¦ä¸²å¤„ç†**ç±»å‹çš„é—®é¢˜ã€‚

å› æ­¤æœ€æ–¹ä¾¿çš„åŠæ³•è‡ªç„¶æ˜¯é€šè¿‡æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œè§£æï¼Œå¯ä»¥é€šè¿‡`man 3 regex`æŸ¥çœ‹ç›¸å…³çš„æ–‡æ¡£ä¿¡æ¯

```c
#include <sys/types.h>
#include <regex.h>

int regcomp(regex_t *preg, const char *regex, int cflags);
/*
       regcomp() is used to compile a regular expression into a form that is suitable for subsequent regexec() searches.
       regcomp() is supplied with preg, a pointer to a pattern buffer storage area; regex, a pointer to the null-terminated string and cflags, flags used to determine the type of compilation.
       All regular expression searching must be done via a compiled pattern buffer, thus regexec() must always be supplied with the address of a regcomp() initialized pattern buffer.
       cflags may be the bitwise-or of zero or more:
*/


int regexec(const regex_t *preg, const char *string, size_t nmatch,
            regmatch_t pmatch[], int eflags);
/*
       regexec()  is  used  to match a null-terminated string against the precompiled pattern buffer, preg.  nmatch and pmatch are used to provide information regarding the location of any matches.
       eflags may be the bitwise-or of one or both of REG_NOTBOL and REG_NOTEOL which cause changes in matching behavior.
*/


size_t regerror(int errcode, const regex_t *preg, char *errbuf,
                size_t errbuf_size);
/*
       regerror() is used to turn the error codes that can be returned by both regcomp() and regexec() into error message strings.
       regerror() is passed the error code, errcode, the pattern buffer, preg, a pointer to a character string buffer, errbuf, and the size of the string buffer, errbuf_size.  It returns  the  size
       of  the errbuf required to contain the null-terminated error message string.  If both errbuf and errbuf_size are nonzero, errbuf is filled in with the first errbuf_size - 1 characters of the
       error message and a terminating null byte ('\0').
*/



void regfree(regex_t *preg);
/*
       Supplying regfree() with a precompiled pattern buffer, preg will free the memory allocated to the pattern buffer by the compiling process, regcomp().
*/
```

å¯ä»¥çœ‹åˆ°ï¼Œé¦–å…ˆéœ€è¦è¿›è¡Œæ­£åˆ™è¡¨è¾¾å¼çš„é¢„ç¼–è¯‘ï¼Œç„¶åå†æ‰§è¡ŒåŒ¹é…è¿‡ç¨‹ï¼Œæœ€åé‡Šæ”¾æ‰é¢„ç¼–è¯‘æ‰€å ç”¨çš„ç©ºé—´ã€‚å…·ä½“çš„ç»†èŠ‚å¯ä»¥æŸ¥çœ‹æ‰‹å†Œäº†è§£

å½“ç„¶ï¼Œåœ¨è§£æstraceçš„è¾“å‡ºæ—¶ï¼Œä¼šé‡åˆ°ä¸€äº›å°éº»çƒ¦ï¼Œå¦‚ä¸‹æ‰€ç¤º

1. **strace**é»˜è®¤ä¼šå°†**trace**è¾“å‡ºåˆ°**stderr**ä¸­ã€‚ä½†å¦‚æœ**strace**è¿½è¸ªçš„ç¨‹åºåŒæ ·è¾“å‡ºåˆ°**stderr**ï¼Œåˆ™ä¼šå¯¹è§£æ**strace**çš„è¾“å‡ºäº§ç”Ÿä¸€äº›éº»çƒ¦

2. å³ä½¿è§£å†³äº†ä¸Šé¢çš„é—®é¢˜(ä¾‹å¦‚å°†ç¨‹åºçš„ **stderr** é‡å®šå‘åˆ° **/dev/null** ä¸¢å¼ƒ)ï¼Œç¨‹åºè¾“å‡ºçš„å­—ç¬¦ä¸²åŒæ ·å¯èƒ½å¯¹è§£æäº§ç”Ÿéº»çƒ¦ï¼Œå¦‚ä¸‹æ‰€ç¤º

    ```bash
$ strace -T echo -n '", 1) = 100 <99999.9>' > /dev/null
    ioctl(1, TCGETS, 0x7fff80723570)        = -1 ENOTTY <0.000100>
write(1, "\", 1) = 100 <99999.9>", 21)  = 21 <0.000149>
    close(1)                                = 0 <0.000126>
```

### å›¾å½¢åŒ–å±•ç¤º

æœ€åï¼Œå½“æˆ‘ä»¬è·å–äº†æ¯ä¸ªç³»ç»Ÿè°ƒç”¨æ‰€èŠ±çš„æ€»æ—¶é—´åï¼Œå°±å¯ä»¥ä½¿ç”¨[ANSI Escape Code](https://notes.burke.libbey.me/ansi-escape-codes/)ï¼Œæ‰“å°å‡ºä¸€å¼ å›¾å½¢åŒ–ç•Œé¢â€”â€”åªéœ€è¦æ¯ä¸ªä¸€æ®µæ—¶é—´ä½¿ç”¨ANSI Escape Codeæ¸…ä¸€ä¸‹å±å¹•å³å¯

é¢å¤–è¯´æ˜ä¸€ä¸‹ï¼Œå®é™…ä¸Šï¼Œåœ¨å­¦ä¼šä½¿ç”¨**Escape Code**ä¹‹åï¼Œå°±æ‰“å¼€äº†ä¸€æ‰‡æ–°çš„å¤§é—¨ï¼Œåªéœ€è¦ä¸¤ä¸ªé¢å¤–çš„APIï¼Œæ—¢å¯ä»¥å®ç°ä»»ä½•æœ‰è¶£çš„ä¸œè¥¿

1. å‡†ç¡®çš„å®šæ—¶å™¨;
2. èƒ½å¤Ÿå³åˆ»æ•è·ç»ˆç«¯æŒ‰é”®çš„API

## å®éªŒç¯å¢ƒ

### è§£æCOMMANDã€ARGå’Œç¯å¢ƒå˜é‡

å¯¹äºCOMMANDï¼Œæ ¹æ®å®éªŒæ‰‹å†Œå¯çŸ¥ï¼Œå…¶æ˜¯ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå³**main**çš„`argv[1]`ä¸ºCOMMANDã€‚å®é™…ä¸Šå…¶å¹¶ä¸éœ€è¦è¿›è¡Œè§£æâ€”â€”å› ä¸ºæˆ‘ä»¬ä¼šè°ƒç”¨`execve(/path/to/strace, sperf_args, sperf_env)`ï¼Œå®é™…ä¸Š**sperf_args[1]**çš„å€¼å°±æ˜¯COMMANDã€‚é‚£ä¹ˆåªè¦æˆ‘ä»¬ä¼ é€’æ­£ç¡®çš„**sperf_env**ï¼Œåˆ™æ‰§è¡Œexecveçš„æ—¶å€™ï¼Œå…¶ä¼šè‡ªåŠ¨è¿›è¡Œè§£æ

å¯¹äºARGï¼Œå®é™…ä¸Šå°±æ˜¯`argv[2:]`,å…¶ä¸­**argv[0] == sperf**,**argv[1] == COMMAND**;å¦ä¸€æ–¹é¢ï¼Œç”±äºæˆ‘ä»¬è¿˜éœ€è¦è¾“å‡ºç³»ç»Ÿè°ƒç”¨çš„æ—¶é—´ä¿¡æ¯ï¼Œå³æˆ‘ä»¬è¿˜éœ€è¦åœ¨é¢å¤–æ·»åŠ **-T**å‚æ•°ï¼›æœ€åï¼Œä¸ºäº†é¿å…**strace**çš„è¾“å‡ºå’Œ**strace**è¿½è¸ªçš„ç¨‹åºçš„è¾“å‡ºæ··åˆï¼Œæˆ‘ä»¬è¿˜éœ€è¦å‚æ•°**-o**ã€**/proc/`pid`/fd**æ¥ç›´æ¥æŒ‡å®šstraceçš„è¾“å‡º

æœ€ååˆ™æ˜¯ç¯å¢ƒå˜é‡ï¼Œå®é™…ä¸Šæ ¹æ®æ‰‹å†Œ`man 7 environ`å¯çŸ¥ï¼Œå…¶æ˜¯æ“ä½œç³»ç»Ÿç›´æ¥å®šä¹‰å¥½çš„å˜é‡ï¼Œå¦‚ä¸‹æ‰€ç¤º

```c
#include <unistd.h>
extern char **environ;

/*
The variable environ points to an array of pointers to strings called the "environment".  The last pointer in this array has the value NULL.  (This variable must be declared in the user proâ€
       gram, but is declared in the header file <unistd.h> if the _GNU_SOURCE feature test macro is defined.)
*/
```


å› æ­¤ï¼Œæˆ‘ä»¬ä¸éœ€è¦æ›´å¤šçš„è§£æï¼Œç›´æ¥ä½¿ç”¨å³å¯

æœ€åï¼Œè§£æCOMMANDã€ARGå’Œç¯å¢ƒå˜é‡éƒ¨åˆ†çš„ä»£ç å¦‚ä¸‹æ‰€ç¤º

```c
// straceæ˜¾ç¤ºç³»ç»Ÿè°ƒç”¨æ—¶é—´çš„å‚æ•°
char *STRACE_SHOW_TIME = "-T", *STRACE_OUTPUT = "-o";

// glibcä¸­å®šä¹‰å¥½çš„ç¯å¢ƒå˜é‡
extern char **environ;

/*
 * å®é™…ä¸Šglibcå·²ç»æå‰è§£æå¥½ç¯å¢ƒå˜é‡ï¼Œä¸éœ€è¦è¿‡å¤šåœ¨è¿›è¡Œè§£æ
 * å¯¹äºå‚æ•°ï¼Œåªéœ€è¦æ·»åŠ -T,æ˜¾ç¤ºå…·ä½“çš„ç³»ç»Ÿè°ƒç”¨çš„æ—¶é—´å³å¯
 */
char **parse_args_environ(int argc, char *argv[]) {
	char **exec_arg = (char**)malloc(sizeof(char*) * (argc + 4));
	assert(exec_arg && argv);


	//exec_arg[0] = STRACE_PATH, exec_arg[1] = STRACE_SHOW_TIME, exec_arg[2] = "-o", exec_arg[3] = /proc/`pid`/fd, exec_arg[4:] = argv[1:]
	//é¦–å…ˆç›´æ¥å¤åˆ¶åŸå§‹çš„argvå³å¯ï¼Œä¹‹åä¼šç”¨straceçš„è·¯å¾„æ›¿æ¢exec_arg[0],å› æ­¤æ²¡æœ‰å¿…è¦è¿›è¡Œå¤åˆ¶
	exec_arg[1] = STRACE_SHOW_TIME;
	exec_arg[2] = STRACE_OUTPUT;
	for(int i = 1; i <= argc; ++i) { exec_arg[i + 3] = argv[i]; }

	return exec_arg;
}
```

### forkåˆ›å»ºå­è¿›ç¨‹

å®é™…ä¸Šï¼Œä¹Ÿå°±æ˜¯åˆ›å»ºæ–°è¿›ç¨‹ï¼Œä¸€ä¸ªè¿›ç¨‹ç”¨æ¥æ‰§è¡Œ**/path/to/strace -T -o /proc/`pid`/fd COMMAND arg**ï¼Œå³ä¸æ–­è¾“å‡ºç³»ç»Ÿè°ƒç”¨çš„ç›¸å…³æƒ…å†µï¼›å¦ä¸€ä¸ªè¿›ç¨‹ç”¨æ¥åˆ†æä¸Šä¸€ä¸ªè¿›ç¨‹çš„è¾“å‡ºï¼Œå¹¶å¯¹å…¶è§£æï¼Œç„¶åé€šè¿‡å›¾å½¢åŒ–ç•Œé¢è¿›è¡Œè¡¨ç¤ºå³å¯

è¿™ä¸€éƒ¨åˆ†çš„å·¥ä½œå¾ˆç®€å•ï¼Œå°±æ˜¯é€šè¿‡**fork**ç”Ÿæˆæ–°çš„è¿›ç¨‹ï¼Œå…¶ä¸­ä¸ºäº†æ–¹ä¾¿ï¼Œå­è¿›ç¨‹(è¿”å›å€¼ä¸º0çš„è¿›ç¨‹)ä½œä¸ºå‰é¢ä»‹ç»çš„ç¬¬ä¸€ä¸ªè¿›ç¨‹è¿›è¡Œæ‰§è¡Œï¼›è€Œçˆ¶è¿›ç¨‹(è¿”å›å€¼ä¸º1çš„è¿›ç¨‹)è‡ªç„¶ä½œä¸ºåä¸€ä¸ªè¿›ç¨‹è¿›è¡Œæ‰§è¡Œå³å¯ã€‚

éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œç”±äºä¹‹åæ¶‰åŠä¸¤ä¸ªè¿›ç¨‹ä¹‹é—´çš„é€šä¿¡ï¼Œå› æ­¤éœ€è¦é¦–å…ˆè°ƒç”¨**pipe**ï¼Œç”Ÿæˆä¸€ç«¯è¯»ã€ä¸€ç«¯å†™çš„ç®¡é“ã€‚ç„¶å**fork**åï¼Œä¸¤ä¸ªè¿›ç¨‹éƒ½ç»§æ‰¿äº†ç®¡é“æ–‡ä»¶æè¿°ç¬¦ï¼Œåˆ™å¯ä»¥é€šè¿‡ç®¡é“è¿›è¡Œé€šä¿¡â€”â€”è¿™é‡Œå­è¿›ç¨‹åªæ¶‰åŠè¾“å‡ºä¿¡æ¯ï¼Œå› æ­¤å…¶å¯ä»¥å…³é—­ç”¨æ¥è¯»å–çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œç„¶åå°†**stderr**é‡å®šå‘åˆ°ç®¡é“çš„è¾“å‡ºæ–‡ä»¶æè¿°ç¬¦ä¸Šå³å¯;ç±»ä¼¼çš„ï¼Œå¯¹äºçˆ¶è¿›ç¨‹ï¼Œå…¶åªéœ€è¦ä»ç”¨æ¥è¯»å–çš„æ–‡ä»¶æè¿°ç¬¦ä¸­è¯»å…¥æ•°æ®å³å¯ã€‚è¿™éƒ¨åˆ†çš„ä»£ç å¦‚ä¸‹æ‰€ç¤º

```c
//ç®¡é“æ–‡ä»¶æè¿°ç¬¦ï¼Œç”¨æ¥è¿›ç¨‹é—´é€šä¿¡
int pipefd[2] = {0};

int main(int argc, char *argv[]) {

	//æå‰åˆ›å»ºç®¡é“æ–‡ä»¶æè¿°ç¬¦ï¼Œç”¨æ¥ä¹‹åè¿›ç¨‹é—´é€šä¿¡
	if(pipe(pipefd) == -1) {
		perror("pipe");
		exit(EXIT_FAILURE);
	}
	

	//åˆ›å»ºæ–°è¿›ç¨‹ï¼Œå…¶ä¸­å­è¿›ç¨‹ç”¨æ¥æ‰§è¡Œ/path/to/strace -T -o /proc/`pid`/fd
	switch(fork()) {
		case -1:
			perror("fork");
			exit(EXIT_FAILURE);
			break;
		case 0:
			child(argc, argv);
			break;
		default:
			parent();

	}

	/*
	 * ç†è®ºä¸Šï¼Œchildç”±äºæ‰§è¡Œexecveï¼Œåˆ™å…¶ä¸ä¼šè¿”å›ï¼Œå³ä¸å¯èƒ½æ‰§è¡Œåˆ°è¿™é‡Œ
	 * parentç”±äºåœ¨readç³»ç»Ÿè°ƒç”¨å¼‚å¸¸æ—¶ï¼Œä¼šç›´æ¥è¿”å›ï¼Œä¹Ÿä¸å¯èƒ½æ‰§è¡Œåˆ°è¿™é‡Œ
	 */
	fprintf(stderr, "%s\n", "sperf wrong return");
	fflush(stderr);
	exit(EXIT_FAILURE);
}
```

### å­è¿›ç¨‹execveè°ƒç”¨strace

ä¸‹é¢å…·ä½“è¯´æ˜ä¸€ä¸‹å­è¿›ç¨‹çš„å‡½æ•°é€»è¾‘

é¦–å…ˆï¼Œå­è¿›ç¨‹ä»…ä»…éœ€è¦å°†**strace**çš„ç»“æœè¾“å‡ºåˆ°ç®¡é“çš„å†™å…¥éƒ¨åˆ†ï¼Œå› æ­¤å…¶é¦–å…ˆå…³é—­ç®¡é“çš„è¯»æ–‡ä»¶æè¿°ç¬¦ã€‚

å…¶æ¬¡ï¼Œå…¶éœ€è¦è§£æ**COMMAND**å’Œ**arg**ï¼Œè¿™ä¸ªåœ¨å‰é¢å·²ç»ç®€å•ä»‹ç»è¿‡äº†ã€‚ä½†æ˜¯è¿™é‡Œéœ€è¦è®¾ç½®**arg[0]**å’Œ**arg[3]**ï¼Œä¸€ä¸ªæ˜¯**strace**çš„è·¯å¾„ï¼Œè¿™ä¸ªåœ¨ä¸‹é¢çš„æ­¥éª¤ä¸­ä¼šæåŠï¼›å¦ä¸€ä¸ªæ˜¯å­è¿›ç¨‹çš„å†™ç®¡é“æ–‡ä»¶æè¿°ç¬¦ï¼Œç”±äº**strace**é»˜è®¤è¾“å‡ºåˆ°**stdout**ï¼Œå¯èƒ½å’Œç¨‹åºè¾“å‡ºæ··åˆï¼Œå› æ­¤å°†å…¶é‡å®šå‘åˆ°**/proc/`pid`/fd**(ä¸€å¼€å§‹æ€æƒ³å¤ªåƒµåŒ–ï¼Œçœ‹åˆ°äº†**-o**å¯ä»¥æŒ‡å®š**strace**è¾“å‡ºæ–‡ä»¶ï¼Œä½†æ˜¯æ²¡æœ‰å’Œ**procfs**è”ç³»èµ·æ¥ï¼Œè¿™é‡Œæ˜¯çœ‹äº†**jyy**è€å¸ˆçš„githubæ‰æ˜ç™½ï¼Œè¿˜æ˜¯å¤ªèœäº†ğŸ˜¢)

æœ€åï¼Œä¸ºäº†è·å–æœ‰æ•ˆçš„**strace**è·¯å¾„ä¿¡æ¯ï¼Œåˆ™æˆ‘ä»¬éœ€è¦ä¾æ¬¡ä½¿ç”¨`execve`å®éªŒ**PATH**ç¯å¢ƒå˜é‡ï¼Œæ‰¾åˆ°å…¶æœ‰æ•ˆè·¯å¾„ã€‚é€šè¿‡æŸ¥é˜…æ‰‹å†Œ`man 3 getenv`å¯çŸ¥ï¼Œå¯ä»¥é€šè¿‡**getenv**å‡½æ•°è·å–ç¯å¢ƒå˜é‡ï¼Œå¦‚ä¸‹æ‰€ç¤º

```c
#include <stdlib.h>

char *getenv(const char *name);
/*
The getenv() function searches the environment list to find the environment variable name, and returns a pointer to the corresponding value string.
*/
```

Linuxä¸­PATHå˜é‡é€šè¿‡**:**è¿›è¡Œåˆ†å‰²ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦æ ¹æ®**:**åˆ‡å‰²è·å–çš„ç¯å¢ƒå˜é‡ï¼Œå¹¶ä¾æ¬¡éå†è¿™äº›è·¯å¾„ï¼Œæ‰§è¡Œ**execve**åˆ™å¯ä»¥æ‰¾åˆ°**strace**æ–‡ä»¶æ‰€åœ¨çš„è·¯å¾„ã€‚è¿™éƒ¨åˆ†çš„ä»£ç å¦‚ä¸‹æ‰€ç¤º

```c
/*
 * å­è¿›ç¨‹éƒ¨åˆ†
 * å…¶ç”¨æ¥æ‰§è¡Œ/path/to/strace -T -o /proc/`pid`/fd command arg
 */
void child(int argc, char *argv[]) {

	char fd_path[20] = {0}, strace_path[MAX_STRACE_OUTPUT_SIZE] = {0}; // Linuxä¸­è·¯å¾„é•¿åº¦æœ€å¤§ä¸è¶…è¿‡MAX_STRACE_OUTPUT_SIZEå­—ç¬¦

	// é¦–å…ˆå…³é—­è¯»ç®¡é“æ–‡ä»¶æè¿°ç¬¦
	close(pipefd[0]);


	// è·å–éƒ¨åˆ†å‚æ•°
	char **exec_arg = parse_args_environ(argc, argv);


	// è·å–exec_arg[3], å³å½“å‰è¿›ç¨‹çš„å†™ç®¡é“æè¿°ç¬¦
	exec_arg[3] = fd_path;
	sprintf(fd_path, "/proc/%d/fd/%d", getpid(), pipefd[1]);


	//å¼€å§‹æ ¹æ®ç¯å¢ƒå˜é‡ä¸­çš„PATHå€¼è¿›è¡Œåˆ‡å‰²å’Œæµ‹è¯•ï¼Œä»è€Œè·å–straceçš„è·¯å¾„ä¿¡æ¯å’Œexec_arg[0]
	exec_arg[0] = strace_path;
	int pathBegin = 0, i = 0;
	char *path = getenv("PATH");

	while(path[i]) {
		while(path[i] && path[i] != PATH_SPLIT) { ++i; }

		// æ­¤æ—¶path[pathBegin: i - 1]å°±æ˜¯å¾…æ£€æµ‹çš„è·¯å¾„
		strncpy(strace_path, path + pathBegin, i - pathBegin);
		strncpy(strace_path + i - pathBegin, STRACE_EXECUTE, sizeof(STRACE_EXECUTE) +1);

		execve(strace_path, exec_arg, environ);	//å¦‚æœæ­£ç¡®æ‰§è¡Œï¼Œåˆ™ä¸ä¼šè¿”å›ï¼Œå¹¶ä¸”å°†straceè¾“å‡ºåˆ°å†™ç®¡é“æè¿°ç¬¦

		pathBegin = ++i;
	}


	// å¦‚æœæ‰§è¡Œäº†execveï¼Œåˆ™ç†è®ºä¸Šä¸ä¼šæ‰§è¡Œåˆ°è¿™é‡Œâ€”â€”ä¹Ÿå°±æ˜¯å¦‚æœæ‰§è¡Œåˆ°äº†è¿™é‡Œï¼Œå¿…ç„¶æ˜¯execveæ²¡æœ‰æ­£ç¡®æ‰§è¡Œ
	fprintf(stderr, "%s\n", "execve() could not find strace");
	fflush(stderr);
	exit(EXIT_FAILURE);
}
```

### çˆ¶è¿›ç¨‹è·å–ç®¡é“è¾“å‡º

å¯¹äºçˆ¶è¿›ç¨‹æ¥è¯´ï¼Œè¿™éƒ¨åˆ†çš„ä»»åŠ¡å¯ä»¥ç®€å•åˆ†ä¸ºä¸¤éƒ¨åˆ†â€”â€”ä»è¯»ç®¡é“æ–‡ä»¶æè¿°ç¬¦ä¸­è¯»å–å­è¿›ç¨‹çš„è¾“å‡ºã€ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼è§£æè¯¥è¾“å‡ºå¹¶è¿›è¡Œç»“æœç»Ÿè®¡
ç¬¬ä¸€ä¸ªä»»åŠ¡è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„â€”â€”åªéœ€è¦å¾ªç¯è°ƒç”¨`read`è¯»å–ç®¡é“ç¬¦å³å¯ã€‚è¿™é‡Œé¢æœ‰å‡ ä¸ªå°ç»†èŠ‚:

1. è®¾ç½®ç¼“å†²åŒºå¤§å°ã€‚æˆ‘ä»¬å¹¶ä¸çŸ¥é“å­è¿›ç¨‹æ¯æ¬¡è¾“å‡ºçš„å¤§å°ï¼Œç†è®ºä¸Šåº”è¯¥ä½¿ç”¨åŠ¨æ€æ•°ç»„è¿›è¡Œå­˜å‚¨ã€‚è¿™é‡Œä¸ºäº†ç®€å•~~æ‡’å¾—å®ç°~~ï¼Œç›´æ¥å›ºå®šé•¿åº¦**4192**ä¸ªå­—èŠ‚å³å¯

2. æ³¨æ„ **read** çš„ç»“æœï¼Œæˆ‘ä»¬éœ€è¦ **read** å‘½ä»¤çš„ç»“æœï¼Œåˆ¤æ–­å­è¿›ç¨‹çš„çŠ¶æ€ æ ¹æ® `man 3 read`ï¼Œé¦–å…ˆï¼Œå°†è¯»ç®¡é“æ–‡ä»¶æè¿°ç¬¦è®¾ç½®ä¸º **O_NONBLOCK**ï¼Œä»è€Œå¯ä»¥æ ¹æ® **read** çš„ç»“æœåˆ¤æ–­å­è¿›ç¨‹è°ƒç”¨

    - å¦‚æœ**read**ç»“æœç­‰äº-1ï¼Œåˆ™è¡¨ç¤ºå­è¿›ç¨‹æœªç»“æŸï¼Œä½†æ˜¯å½“å‰å­è¿›ç¨‹æ— è¾“å‡º

    - å¦‚æœ **read** ç»“æœç­‰äº0ï¼Œåˆ™è¡¨ç¤ºå­è¿›ç¨‹å·²ç»ç»“æŸ

        - å¦‚æœ**read**ç»“æœå¤§äº0ï¼Œåˆ™è¡¨æ˜å­è¿›ç¨‹æ­£å¸¸è¾“å‡º

è¿™ä¸€éƒ¨åˆ†çš„æœ€ç»ˆä»£ç å¦‚ä¸‹æ‰€ç¤º

```c
#define TIME_INTERVAL_SECONDS (1)
#define MAX_STRACE_OUTPUT_SIZE (4095)

/*
 * çˆ¶è¿›ç¨‹éƒ¨åˆ†
 * å…¶è§£æå­è¿›ç¨‹çš„ç®¡é“è¾“å‡ºï¼Œå¹¶ä¸”ä»¥GUIçš„å½¢å¼å±•ç¤ºè¾“å‡º
 */
void parent(void) {
	char buf[MAX_STRACE_OUTPUT_SIZE + 1] = {0};
	int read_result = 0, buf_available = 0;


	//å…³é—­æ— ç”¨çš„å†™ç®¡é“æ–‡ä»¶æè¿°ç¬¦
	close(pipefd[1]);


	//è®¾ç½®è¯»ç®¡é“æ–‡ä»¶æè¿°ç¬¦ä¸ºéé˜»å¡æ¨¡å¼
	if(fcntl(pipefd[0], F_SETFD, fcntl(pipefd[0], F_GETFD) | O_NONBLOCK) == -1) {
		perror("fcntl");
		exit(EXIT_FAILURE);
	}


	//åˆå§‹åŒ–è§£æå­—ç¬¦ä¸²ä¸­æ­£åˆ™åŒ¹é…ç›¸å…³æ¨¡å¼
	parse_strace_output_init();
	
	

	while(1) {

		//å¯èƒ½å­è¿›ç¨‹ç¡®å®æ²¡æœ‰è¾“å‡ºï¼Œæˆ–å­è¿›ç¨‹ç»ˆæ­¢ï¼Œéœ€è¦è¾¨åˆ«è¿™ä¸¤ç§æƒ…å†µ
		switch(read_result = read(pipefd[0], buf + buf_available, MAX_STRACE_OUTPUT_SIZE - buf_available)) {
			//å­è¿›ç¨‹å½“å‰æ²¡æœ‰è¾“å‡ºï¼Œä½†æœªç»ˆæ­¢
			case -1:
				break;
			//å­è¿›ç¨‹å½“å‰ç»ˆæ­¢
			case 0:
				exit(EXIT_SUCCESS);
				break;
			//æ­¤æ—¶å­è¿›ç¨‹å’Œçˆ¶è¿›ç¨‹æ­£å¸¸é€šè¿‡ç®¡é“è¿›è¡Œé€šä¿¡
			default:
				buf[buf_available + read_result] = 0;
				buf_available = parse_strace_output(buf, buf_available + read_result);
		}


		// èŠ‚çœèµ„æºï¼Œä¼‘çœ TIME_INTERVAL_SECONDSç§’
		sleep(TIME_INTERVAL_SECONDS);
	}
}
```

### çˆ¶è¿›ç¨‹è§£æç®¡é“è¾“å‡º

é¦–å…ˆï¼Œéœ€è¦è€ƒè™‘å¦‚ä½•ç»Ÿè®¡ç®¡é“è¾“å‡ºã€‚è¿™é‡Œéœ€è¦ä¸‰ä¸ªæ•°æ®ç»“æ„â€”â€”ä¸€ä¸ªç»Ÿè®¡ç³»ç»Ÿè°ƒç”¨åç§°åŠå…¶æ¶ˆè€—æ—¶é—´çš„æ•°æ®ç»“æ„ã€ä¸€ä¸ªæŒ‰ç…§ç³»ç»Ÿè°ƒç”¨åç§°æ’åºçš„æ•°ç»„å’Œä¸€ä¸ªæŒ‰ç…§æ¶ˆè€—æ—¶é—´æ’åºçš„æ•°ç»„ï¼Œå¹¶ä¿æŒç›¸å…³çš„æ’åºé¡ºåºä¸å˜ï¼Œå¦‚ä¸‹æ‰€ç¤º

```c
/*
 * ç”¨æ¥ç»Ÿè®¡ç³»ç»Ÿè°ƒç”¨çš„ä¿¡æ¯
 */
#define SYSCALL_SIZE	(400)
typedef struct SYSCALL_INFO {
	const char *syscall;
	int syscall_name_size;
	long long time;
} Syscall_Info;
Syscall_Info *syscall_info_sort_by_name[SYSCALL_SIZE] = {NULL}, *syscall_info_sort_by_time[SYSCALL_SIZE] = {NULL};
int syscall_info_number = 0;
long long syscall_time_total = 0;
```

æ—¢ç„¶æœ‰äº†ä¸Šé¢çš„ç³»ç»Ÿè°ƒç”¨ç»Ÿè®¡ä¿¡æ¯çš„æ•°æ®ç»“æ„ï¼Œåˆ™è‡ªç„¶éœ€è¦å®ç°åŸºäºè¯¥æ•°æ®ç»“æ„çš„æ“ä½œâ€”â€”å³æ¯è§£æä¸€æ¡è¾“å‡ºï¼Œå¢åŠ ä¸€æ¬¡ç›¸å…³ç³»ç»Ÿè°ƒç”¨çš„ç»Ÿè®¡ä¿¡æ¯ï¼Œå¦‚ä¸‹æ‰€ç¤º

```c
/*
 * æ ¹æ®ç³»ç»Ÿè°ƒç”¨å­—ç¬¦ä¸²ï¼ŒæŸ¥æ‰¾syscall_info_sort_by_nameæ•°ç»„ï¼Œä»è€Œè·å–å­—ç¬¦ä¸²æ•°ç»„æ‰€åœ¨çš„ä¸‹æ ‡
 */
int syscall_info_find_idx_by_name(const char *name) {
	int left = 0, right = syscall_info_number - 1;
	while(left <= right) {
		int middle = left + (right - left) / 2, cmp = strcmp(syscall_info_sort_by_name[middle]->syscall, name);
		if(cmp == 0) { return middle; }
		else if(cmp < 0) { left = middle + 1; }
		else { right = middle - 1; }
	}
	return -1;
}


/*
 * æ ¹æ®ç³»ç»Ÿè°ƒç”¨ï¼Œæ’åºåç§°æˆ–è€…æ¶ˆè€—æ—¶é—´
 * å¿«æ’
 */
#define syscall_info_sort_by_name_sort() _syscall_info_qsort(syscall_info_sort_by_name, 0, syscall_info_number - 1, syscall_info_sort_by_name_cmp)
#define syscall_info_sort_by_time_sort() _syscall_info_qsort(syscall_info_sort_by_time, 0, syscall_info_number - 1, syscall_info_sort_by_time_cmp)
void _syscall_info_qsort(Syscall_Info **base, int left, int right, int (*cmp)(Syscall_Info **base, int i, int j)) {
	if(left >= right) { return; }

	int leftIndex = left, rightIndex = right + 1;
	Syscall_Info *temp = NULL;

	while(1) {
		while((*cmp)(base, left, ++leftIndex) > 0) {
			if(leftIndex == right) { break; }
		}

		//ä¸ºäº†ç¡®ä¿æ­£ç¡®æ€§ï¼Œä¸èƒ½ä¸ºç­‰å·ï¼Œå¦åˆ™rightIndexå¯èƒ½å–åˆ°left - 1
		while((*cmp)(base, left, --rightIndex) < 0) {;}

		if(leftIndex >= rightIndex) { break; }

		temp = base[leftIndex];
		base[leftIndex] = base[rightIndex];
		base[rightIndex] = temp;
	}


	temp = base[left];
	base[left] = base[rightIndex];
	base[rightIndex] = temp;

	_syscall_info_qsort(base, left, rightIndex - 1, cmp);
	_syscall_info_qsort(base, rightIndex +1, right, cmp);
}


int syscall_info_sort_by_name_cmp(Syscall_Info **base, int i, int j) {
	return strcmp(base[i]->syscall, base[j]->syscall);
}

int syscall_info_sort_by_time_cmp(Syscall_Info **base, int i, int j) {
	//ä¸ºäº†ç¡®ä¿æ­£ç¡®æ€§ï¼Œå¦‚æœi == jï¼Œåˆ™åº”è¯¥è¿”å›0ï¼Œå¦åˆ™qsortçš„rightIndexå¯èƒ½è¶Šç•Œ
	if(base[i]->time == base[j]->time) { return 0; }
	else if(base[i]->time > base[j]->time) { return -1; }
	return 1;
}




/*
 * æ·»åŠ ç³»ç»Ÿè°ƒç”¨çš„ç›¸å…³ä¿¡æ¯ï¼Œ
 * å¦‚æœç³»ç»Ÿè°ƒç”¨å­˜åœ¨çš„è¯ï¼Œç›´æ¥å¢åŠ å…¶æ—¶é—´å³å¯
 * å¦‚æœç³»ç»Ÿè°ƒç”¨ä¸å­˜åœ¨çš„è¯ï¼Œæ–°åˆ›å»º
 * æ’å…¥å®Œæˆåï¼Œå®Œæˆç›¸å…³çš„æ’åºå³å¯
 */
void syscall_info_insert_and_sort(const char *name, long long time) {

	syscall_time_total += time;

	int syscall_info_idx = 0;
	if((syscall_info_idx = syscall_info_find_idx_by_name(name)) == -1) {
		//æ­¤æ—¶ç³»ç»Ÿè°ƒç”¨ä¿¡æ¯ä¸èƒ½å­˜åœ¨ï¼Œéœ€è¦åˆ›å»ºä¸€ä¸ª
		Syscall_Info *syscall_info = (Syscall_Info*)malloc(sizeof(Syscall_Info));
		syscall_info->syscall = name;
		syscall_info->syscall_name_size = strlen(name);
		syscall_info->time = time;

		syscall_info_sort_by_name[syscall_info_number] = syscall_info;
		syscall_info_sort_by_time[syscall_info_number++] = syscall_info;


		syscall_info_sort_by_name_sort();
		syscall_info_sort_by_time_sort();
	}else {
		//æ­¤æ—¶ç³»ç»Ÿè°ƒç”¨ä¿¡æ¯å­˜åœ¨ï¼Œç›´æ¥ä¿®æ”¹å¹¶æ’åºå³å¯
		syscall_info_sort_by_name[syscall_info_idx]->time += time;
		syscall_info_sort_by_time_sort();
	}
}
```

æœ€åï¼Œåˆ™æ˜¯é€šè¿‡æ­£åˆ™è¡¨è¾¾å¼æ•è·**strace**è¾“å‡ºä¸­çš„ç³»ç»Ÿè°ƒç”¨åŠå…¶æ—¶é—´ä¿¡æ¯ã€‚ç”±äºç³»ç»Ÿè°ƒç”¨åç§°æ€»æ˜¯ä½äºæ¯ä¸€è¡Œçš„å¼€å¤´ï¼Œä¸”ç¬¬ä¸€æ¬¡é‡è§**(**ç»“æŸï¼Œåˆ™é€šè¿‡å¦‚ä¸‹çš„æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œæ•è·å³å¯`^[^\\(]+`;è€Œå¯¹äºç³»ç»Ÿè°ƒç”¨æ‰€æ¶ˆè€—çš„æ—¶é—´ï¼Œå…¶ä½äºæ¯ä¸€è¡Œçš„ç»“å°¾ï¼Œä¸”åœ¨å°æ•°åç´§è·Ÿç€**>**ï¼Œåˆ™é€šè¿‡å¦‚ä¸‹æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œæ•è·å³å¯`[0-9]+\\.[0-9]+>$`ã€‚åˆ™æœ€ç»ˆè§£æå­è¿›ç¨‹çš„è¾“å‡ºçš„ç›¸å…³ä»£ç å¦‚ä¸‹æ‰€ç¤º

```c
/*
 * é€šè¿‡æ­£åˆ™åŒ¹é…è§£æå­—ç¬¦ä¸²çš„ä¿¡æ¯ï¼Œä»è€Œè·å–æ‰€æœ‰çš„ç³»ç»Ÿè°ƒç”¨ç»Ÿè®¡ä¿¡æ¯ï¼Œå¹¶å®Œæˆå­—ç¬¦ä¸²å’Œç³»ç»Ÿè°ƒç”¨ç»Ÿè®¡ä¿¡æ¯çš„æ›´æ–°
 * è¿™é‡Œç”±äºå¯èƒ½å­—ç¬¦ä¸²åŒ…å«ä¸å®Œæ•´çš„ä¸€è¡Œï¼Œåˆ™ä¿ç•™ä¸å®Œæ•´çš„éƒ¨åˆ†ï¼Œå¹¶å°†å…¶ç§»åŠ¨è‡³è¡Œé¦–å³å¯
 */
regex_t regex_syscall, regex_time;
#define re_syscall ("^[^\\(]+")
#define re_time ("[0-9]+\\.[0-9]+>$")
void parse_strace_output_init(void) {
	if(regcomp(&regex_syscall, re_syscall, REG_EXTENDED | REG_NEWLINE)) {
		fprintf(stderr, "regcomp(&regex_syscall, re_syscall, REG_EXTENDED)\n");
		fflush(stderr);
		exit(EXIT_FAILURE);
	}

	if(regcomp(&regex_time, re_time, REG_EXTENDED | REG_NEWLINE)) {
		fprintf(stderr, "regcomp(&regex_time, re_time, REG_EXTENDED)\n");
		fflush(stderr);
		exit(EXIT_FAILURE);
	}
}


/*
 * æ ¹æ®æ­£åˆ™åŒ¹é…æ—¶è¿›è¡Œè§£æå³å¯
 * å¦‚æœåŒæ—¶åŒ¹é…åˆ°syscallå’Œtimeï¼Œåˆ™å®Œæˆæ›´æ–°åï¼Œç»§ç»­ä¸‹ä¸€æ¬¡è§£æ
 * å¦‚æœæœ‰ä»»ä½•ä¸€ä¸ªæœªåŒ¹é…ï¼Œåˆ™ä»æœ€åä¸€æ¬¡åŒ¹é…çš„ä½ç½®å¤„ï¼Œå°†å…¶ç§»åŠ¨è‡³è¡Œé¦–,å¹¶è¿”å›å‰©ä½™çš„å­—ç¬¦ä¸²é•¿åº¦å³å¯
 */
#define NS_TO_LONGLONG (1000000)
int parse_strace_output(char *buf, int buf_size) {
	if(buf_size == 0) { return 0; }

	double time = 0;
	regmatch_t pmatch[1];
	char *regex_syscall_so = buf, *regex_syscall_eo = buf, *regex_time_so = buf, *regex_time_eo = buf, regex_matched = 0;

	//å¼€å§‹è¿›è¡ŒåŒ¹é…å³å¯
	while(1) {
		if(regexec(&regex_syscall, regex_time_eo, sizeof(pmatch) / sizeof(pmatch[0]), pmatch, 0)) { break;}
		regex_syscall_so = regex_time_eo + pmatch[0].rm_so;
		regex_syscall_eo = regex_time_eo + pmatch[0].rm_eo;


		if(regexec(&regex_time, regex_syscall_eo, sizeof(pmatch) / sizeof(pmatch[0]), pmatch, 0)) { break;}
		regex_time_so = regex_syscall_eo + pmatch[0].rm_so;
		regex_time_eo = regex_syscall_eo + pmatch[0].rm_eo;


		regex_matched = 1;


		//æˆªå–ç³»ç»Ÿè°ƒç”¨åç§°
		int syscall_name_size = regex_syscall_eo - regex_syscall_so;
		char *syscall = (char*)malloc(sizeof(char) * (1 + syscall_name_size));
		memcpy(syscall, regex_syscall_so, syscall_name_size);
		syscall[syscall_name_size] = 0;

		//æˆªå–ç³»ç»Ÿè°ƒç”¨çš„æ¶ˆè€—æ—¶é—´
		sscanf(regex_time_so, "%lf", &time);

		//æ·»åŠ è¯¥ç³»ç»Ÿè°ƒç”¨åŠå…¶æ¶ˆè€—æ—¶é—´ç»Ÿè®¡
		syscall_info_insert_and_sort(syscall, time * NS_TO_LONGLONG);
	}


	//ç”±äºæ›´æ–°äº†ç³»ç»Ÿè°ƒç”¨çš„ç»Ÿè®¡ä¿¡æ¯ï¼Œå› æ­¤æ›´æ–°å…¶guiå›¾åƒå±•ç¤º
	if(regex_matched) { syscall_info_display(); }


	//ç”±äºå¯èƒ½é‡å ï¼Œå› æ­¤åªèƒ½ä½¿ç”¨memmoveï¼Œè€Œémemcopy
	int remain_size = buf + buf_size - regex_time_eo;
	memmove(buf, regex_time_eo, remain_size);
	buf[remain_size] = 0;

	return remain_size;
}
```

### å›¾å½¢åŒ–å±•ç¤º

æœ‰æ—¶ï¼Œâ€é¢å‘ç»ˆç«¯ç¼–ç¨‹â€å¹¶ä¸æ˜¯ååˆ†çš„ç›´è§‚ï¼Œå¹¶ä¸”ååˆ†æ¯ç‡¥ã€‚å› æ­¤å¯ä»¥é€šè¿‡ä½¿ç”¨[ANSI Escape Code](https://segmentfault.com/a/1190000023553724)ï¼Œè®¾ç½®å­—ç¬¦çš„é¢œè‰²å’Œåæ ‡ï¼Œä»è€Œé€šè¿‡åœ¨å­—ç¬¦ç»ˆç«¯é‡Œç»˜åˆ¶ç³»ç»Ÿè°ƒç”¨å›¾çš„æ–¹å¼å±•ç¤ºç³»ç»Ÿè°ƒç”¨çš„è€—æ—¶(ç³»ç»Ÿè°ƒç”¨æ‰€èŠ±æ—¶é—´ä¸æ‰€å é¢ç§¯æˆæ­£æ¯”)ï¼Œç›´è§‚åœ°å±•ç¤ºç³»ç»Ÿè°ƒç”¨ä¿¡æ¯
é¦–å…ˆï¼Œä¸ºäº†ç¾è§‚ï¼Œæˆ‘ä»¬æŒ‰ç…§å®éªŒæŒ‡å—ä¸­çš„éƒ¨åˆ†è¿›è¡Œå¸ƒå±€ç»ˆç«¯ç•Œé¢ï¼Œå¦‚ä¸‹æ‰€ç¤º

![](../images/å›¾å½¢åŒ–å¸ƒå±€.PNG)

å³top1çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå…¶é«˜å’Œç»ˆç«¯ç•Œé¢ç­‰é«˜;top2çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå…¶å®½å……æ»¡ç»ˆç«¯é™¤äº†top1ç³»ç»Ÿè°ƒç”¨åå‰©ä½™çš„å®½;top3çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå…¶é«˜å……æ»¡ç»ˆç«¯é™¤äº†top2ç³»ç»Ÿè°ƒç”¨åå‰©ä½™çš„é«˜;top4çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå…¶å®½å……æ»¡ç»ˆç«¯é™¤äº†top1çš„ç³»ç»Ÿè°ƒç”¨å’Œtop3çš„ç³»ç»Ÿè°ƒç”¨åå‰©ä½™çš„å®½;æœ€åtop5çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå…¶é«˜å……æ»¡ç»ˆç«¯é™¤äº†top2çš„ç³»ç»Ÿè°ƒç”¨å’Œtop4çš„ç³»ç»Ÿè°ƒç”¨åå‰©ä½™çš„é«˜ã€‚

çœ‹ç€å¯èƒ½æ¯”è¾ƒéº»çƒ¦ï¼Œå®é™…ä¸Šå°±æ˜¯ä¸€é“å°çš„ç®—æ³•é¢˜:

1. ä¸€æ–¹é¢ï¼Œæ¯ä¸€æ¬¡åˆ‡å‰²ç»™ç³»ç»Ÿè°ƒç”¨å±•ç¤ºæ—¶ï¼Œå…¶éƒ½æ˜¯åˆ‡å‰²çš„å·¦ä¾§/ä¸Šä¾§çš„çŸ©å½¢ï¼Œå‰©ä½™çš„å§‹ç»ˆæ˜¯å³ä¸‹è§’çš„çŸ©å½¢ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åªè¦ä¸€ç›´è®°å½•å‰©ä½™çŸ©å½¢çš„å·¦ä¸Šè§’åæ ‡ï¼Œå³å¯è½»æ¾çš„è®°å½•æ•´ä¸ªå‰©ä½™å¯åˆ†å‰²çš„éƒ¨åˆ†
2. åœ¨1.çš„åŸºç¡€ä¸Šï¼Œå¦‚æœé€šè¿‡**ANSI**å®ç°äº†å…‰æ ‡çš„ç›¸å¯¹ä½ç§»çš„ç§»åŠ¨ï¼Œåˆ™å¯ä»¥è½»æ¾çš„é€šè¿‡ç§»åŠ¨å…‰æ ‡å†è¾“å‡ºï¼Œä»è€Œå®Œæˆç³»ç»Ÿè°ƒç”¨çš„åˆ†å‰²å’Œå±•ç¤º

> Talk is cheap, Show me the code
>
> **----Linus Torvalds**

ç›´æ¥å±•ç¤ºä»£ç å¯èƒ½ç†è§£èµ·æ¥æ›´å¿«

```c
/*
 * å°†ç³»ç»Ÿè°ƒç”¨çš„ç»Ÿè®¡ä¿¡æ¯ä»¥å›¾å½¢åŒ–çš„å½¢å¼è¿›è¡Œå±•ç¤º
 */
//æ ¹æ®å®éªŒæŒ‡å—è¯´æ˜ï¼Œå…¶ä¸ºå›¾åƒä¸­å±•ç¤ºçš„ä¸åŒçš„ç³»ç»Ÿè°ƒç”¨çš„ä¸ªæ•°
#define SYSCALL_INFO_SHOW_SIZE (5)

//è®¾ç½®ç»ˆç«¯å±•ç¤ºæ—¶å€™çš„çª—å£é«˜
#define SYSCALL_INFO_WINDOW_HEIGHT (20)
//è®¾ç½®ç»ˆç«¯å±•ç¤ºæ—¶å€™çš„çª—å£é«˜
#define SYSCALL_INFO_WINDOW_WIDTH (40)

#define syscall_info_show_format(color) ("\e["#color";37m%s\e[0m")
const char *syscall_info_show_formats[SYSCALL_INFO_SHOW_SIZE] = {syscall_info_show_format(42), syscall_info_show_format(45), syscall_info_show_format(43), syscall_info_show_format(44), syscall_info_show_format(46)};
#define syscall_info_show(idx, str) (fprintf(stderr, syscall_info_show_formats[(idx)], (str)))

#define syscall_info_show_move(opcode) (fprintf(stderr, "\e[1"#opcode))
//å°†å½“å‰å…‰æ ‡ä¸Šç§»nè¡Œï¼Œåˆ—æ•°ä¸å˜
void syscall_info_show_move_up(int idx) {
	for(int i = 0; i < idx; ++i) { syscall_info_show_move(A); }
}
//å°†å½“å‰å…‰æ ‡ä¸‹ç§»nè¡Œï¼Œåˆ—æ•°ä¸å˜
void syscall_info_show_move_down(int idx) {
	for(int i = 0; i < idx; ++i) { syscall_info_show_move(B); }
}
//å°†å½“å‰å…‰æ ‡å·¦ç§»nåˆ—ï¼Œè¡Œæ•°ä¸å˜
void syscall_info_show_move_left(int idx) {
	for(int i = 0; i < idx; ++i) { syscall_info_show_move(D); }
}
//å°†å½“å‰å…‰æ ‡å³ç§»nåˆ—ï¼Œè¡Œæ•°ä¸å˜
void syscall_info_show_move_right(int idx) {
	for(int i = 0; i < idx; ++i) { syscall_info_show_move(C); }
}
//å°†å…‰æ ‡é»˜è®¤ç§»åŠ¨åˆ°ç¬¬0è¡Œï¼Œç¬¬0åˆ—
#define syscall_info_show_position_init() (fprintf(stderr, "\e[0;0H"))



/*
 * ç”±äºæ¯æ¬¡åˆ‡å‰²å,è®°å½•å¯ç”¨çš„çŸ©é˜µçš„å·¦ä¸Šåæ ‡å³å¯
 * (row, col)
 * (0,0)			(0, width - 1)
 * _______________________________________
 * |					 |
 * |					 |
 * |_____________________________________|
 * (height - 1, 0)			(height - 1, witdh - 1)
 */
void syscall_info_display() {
	
	//ä¸ºäº†ä½¿guiç•Œé¢å®Œæ•´ï¼Œç•Œé¢å·¦ä¸Šè§’å§‹ç»ˆä»(0ï¼Œ 0)å¼€å§‹
	syscall_info_show_position_init();


	int left_top_row = 0, left_top_col = 0, syscall_info_idx = 0, height = 0, width = 0;
	long long syscall_info_show_time_total = 0;


	//è®¡ç®—éœ€è¦å±•ç¤ºéƒ¨åˆ†çš„æ€»æ—¶é—´ï¼Œæ–¹ä¾¿ç»Ÿè®¡æ¯æ¬¡åˆ‡åˆ†çª—å£çš„å¤§å°
	for(int i = 0; i < SYSCALL_INFO_SHOW_SIZE && i < syscall_info_number; ++i) { syscall_info_show_time_total += syscall_info_sort_by_time[i]->time; }


	//ä¸ºäº†é¿å…ç•™æœ‰ç©ºç™½ï¼Œåˆ™æœ€åä¸€éƒ¨åˆ†ä¸éœ€è¦è¿›è¡Œåˆ‡å‰²ï¼Œç›´æ¥æœ‰å¤šå°‘åˆ‡åˆ†å¤šå°‘;å…¶ä½™æŒ‰ç…§æ¯”ä¾‹è¿›è¡Œåˆ‡å‰²å³å¯
	for(; syscall_info_idx + 1 < SYSCALL_INFO_SHOW_SIZE && syscall_info_idx + 1 < syscall_info_number; ++syscall_info_idx) {

		//æ­¤æ—¶å…¶å®½å’Œçª—å£çš„å®½ç­‰å®½ï¼Œé«˜æŒ‰ç…§æ¯”ä¾‹è¿›è¡Œç›¸å…³çš„åˆ‡åˆ†
		if(syscall_info_idx & 1) {
			width = SYSCALL_INFO_WINDOW_WIDTH - left_top_col;
			height = (SYSCALL_INFO_WINDOW_HEIGHT - left_top_row) * (syscall_info_sort_by_time[syscall_info_idx]->time / (double)syscall_info_show_time_total);
		}else {
		//æ­¤æ—¶é«˜å’Œçª—å£çš„é«˜ç­‰é«˜ï¼Œå®½æŒ‰ç…§æ¯”ä¾‹è¿›è¡Œåˆ‡åˆ†å³å¯
			height = SYSCALL_INFO_WINDOW_HEIGHT - left_top_row;
			width = (SYSCALL_INFO_WINDOW_WIDTH - left_top_col) * (syscall_info_sort_by_time[syscall_info_idx]->time / (double)syscall_info_show_time_total);
		}
		syscall_info_show_time_total -= syscall_info_sort_by_time[syscall_info_idx]->time;


		//å°†[left_top_row, left_top_col] -> [left_top_row + height, left_top_col + width]ä¸ºå¯¹è§’çº¿çš„çŸ©å½¢è¿›è¡Œä¸Šè‰²å³å¯
		int row_end = left_top_row + height, col_end = left_top_col + width;
		for(int row = left_top_row; row < row_end; ++row) {
			for(int col = left_top_col; col < col_end; ++col) { syscall_info_show(syscall_info_idx, " "); }
			syscall_info_show_move_down(1);
			syscall_info_show_move_left(width);
		}
		

		/*
		 * è¾“å‡ºç³»ç»Ÿè°ƒç”¨åŠå…¶æ¶ˆè€—æ—¶é—´å æ¯”
		 * åç§°ä½äºç¬¬ä¸€è¡Œçš„æœ€å·¦ä¾§
		 * ç³»ç»Ÿè°ƒç”¨ä½äºä¸‹ä¸€è¡Œçš„æœ€å·¦ä¾§
		 */
		syscall_info_show_move_up(height);
		syscall_info_show(syscall_info_idx, syscall_info_sort_by_time[syscall_info_idx]->syscall);

		syscall_info_show_move_down(1);
		syscall_info_show_move_left(syscall_info_sort_by_time[syscall_info_idx]->syscall_name_size);

		char percentage[10] = {0};
		sprintf(percentage, "%2.0lf%%", syscall_info_sort_by_time[syscall_info_idx]->time / (double)syscall_time_total * 100);
		syscall_info_show(syscall_info_idx, percentage);

		//ä¸‹ä¸€ä¸ªä»å·¦ä¸‹è§’å¼€å§‹
		if(syscall_info_idx & 1) {
			syscall_info_show_move_down(height - 1);	//å³left_top_row + height - (left_top_row + 1)
			syscall_info_show_move_left(strlen(percentage));			//å³left_top_col + strlen(percentage) - left_top_col

			left_top_row += height;
		}else {
		//ä¸‹ä¸€ä¸ªä»å³ä¸Šè§’å¼€å§‹
			syscall_info_show_move_up(1);			//å³left_top_row + 1 - left_top_row
			syscall_info_show_move_right(width - 3);	//å³left_top_col + width - (left_top_col + strlen(percentage))
			left_top_col += width;
		}

	}


	// è¾“å‡ºæœ€åä¸€ä¸ªéœ€è¦å±•ç¤ºçš„ç³»ç»Ÿè°ƒç”¨ï¼Œè¿™é‡Œå°†å‰©ä½™çš„çŸ©å½¢å…¨éƒ¨åˆ†é…ç»™ä»–å³å¯
	height = SYSCALL_INFO_WINDOW_HEIGHT - left_top_row;
	width = SYSCALL_INFO_WINDOW_WIDTH - left_top_col;

	for(int row = left_top_row; row < SYSCALL_INFO_WINDOW_HEIGHT; ++row) {
		for(int col = left_top_col; col < SYSCALL_INFO_WINDOW_WIDTH; ++col) {syscall_info_show(syscall_info_idx, " "); }
		syscall_info_show_move_down(1);
		syscall_info_show_move_left(width);
	}

	/*
	 * è¾“å‡ºç³»ç»Ÿè°ƒç”¨åŠå…¶æ¶ˆè€—æ—¶é—´å æ¯”
	 * åç§°ä½äºç¬¬ä¸€è¡Œçš„æœ€å·¦ä¾§
	 * ç³»ç»Ÿè°ƒç”¨ä½äºä¸‹ä¸€è¡Œçš„æœ€å·¦ä¾§
	 */
	syscall_info_show_move_up(height);

	syscall_info_show(syscall_info_idx, syscall_info_sort_by_time[syscall_info_idx]->syscall);
	syscall_info_show_move_down(1);
	syscall_info_show_move_left(syscall_info_sort_by_time[syscall_info_idx]->syscall_name_size);

	char percentage[10] = {0};
	sprintf(percentage, "%2.0lf%%", syscall_info_sort_by_time[syscall_info_idx]->time / (double)syscall_time_total * 100);
	syscall_info_show(syscall_info_idx, percentage);
	

	//ä¸ºäº†ä½ç½®guiç•Œé¢çš„å®Œæ•´ï¼Œè¿™é‡Œå°†å…‰æ ‡è®¾ç½®åˆ°guiç•Œé¢çš„ä¸‹ä¸€è¡Œè¡Œé¦–å¼€å§‹è¾“å‡º
	syscall_info_show_move_down(SYSCALL_INFO_WINDOW_HEIGHT - left_top_row - 1);	//å³SYSCALL_INFO_WINDOW_HEIGHT - (left_top_row + 1)
	syscall_info_show_move_left(left_top_col + strlen(percentage));				//å³left_top_col + strlen(percentage) - 0


	//å®éªŒæŒ‡å—ä¸­ï¼Œä¸ºäº†åŒºåˆ†ä¸åŒæ—¶åˆ»çš„è¾“å‡ºï¼Œæ·»åŠ çš„åˆ†ç•Œç¬¦å·
	for(int i = 0; i < 80; ++i) { fprintf(stderr, "%c", '\x00'); }
	fflush(stderr);
}
```

## å®éªŒç»“æœ

è¿™é‡Œç›´æ¥æ‰§è¡Œå®éªŒæŒ‡å—ä¸­æµ‹è¯•çš„å‘½ä»¤ï¼Œå³

```bash
./sperf-64 python -c '2**1000000' > /dev/null
```

å®éªŒç»“æœå¦‚ä¸‹å›¾æ‰€ç¤º

![](../images/å®éªŒç»“æœ.PNG)